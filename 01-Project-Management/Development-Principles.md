# 从一次网站调试中学到的核心开发原则

在解决一个看似简单的网站部署问题 Bug 时，我学到了 DRY 原则，并在此基础上探索了其他软件开发的原则。随后总结了它们相通的地方。

---

### 1. DRY 原则 (Don't Repeat Yourself)

**核心思想：** 在系统中，每一处知识都应该有单一、无歧义、权威的表示。

**在这次调试中的体现：**
**👉 [点击这里，查看调试笔记](./Jekyll-Github-Deployment-Debug.md)**

我最初想把我详细的调试过程，既写在 Issue 里，又单独写一篇笔记。但我最终意识到，这样做会产生两个信息源，难以同步和维护。

遂选择将 GitHub Issue 作为这个问题的单一信息源。所有最原始、最完整的记录都集中在那里。而我的笔记库里，只保留一个指向该 Issue 的索引。

### 2. 文档化问题

**核心思想：** 在寻求帮助之前，先通过书写的方式，将问题、你尝试过的所有方法、以及你的预期结果清晰地记录下来。

**在这次调试中的体现：**
当我准备去社区求助时，我没有直接问“我的网站为什么 404？”。而是先编写了一份 GitHub Issue。

* **实践应用：**
    - **强迫自己思考：** 书写的过程本身就是一个深度思考和逻辑梳理的过程，有时写着着自己就找到了答案。
    - **尊重他人时间：** 一份详尽的问题报告，能帮助回答者快速排除错误答案，直击问题核心。
    - **创造长期价值：** 这份 Issue 不仅是我自己的求助帖，更成为了一份公共的技术文档，会被搜索引擎索引。

---

## 除了上面的问题，我额外搜索了开发的原则，作为本知识的扩展。

### 一个问题：软件开发原则不是对代码而言的吗？怎么和笔记处理扯上关系的？

软件开发原则，比如SOLID原则、DRY（Don't Repeat Yourself）、KISS（Keep It Simple, Stupid）、关注点分离（Separation of Concerns）等等，它们本质上是更高级别的抽象思维和设计理念：

1. 它们是模糊的、理念性的：

  - 它们不是具体的代码规则，而是指导我们如何思考、如何设计的方针。例如，“高内聚、低耦合”本身就不是一个能精确测量的指标，而是一种追求目标。

  - 这种模糊性使得它们具有更强的普适性和灵活性。

2. 它们可以扩展到更广泛的层面：

  - 这些原则通常基于组织、沟通、效率、可维护性等基础管理和工程思想。

  - 因此，它们不仅适用于代码结构，也完全可以应用于：

    + 软件架构设计（选择微服务、单体等）。

    + 项目管理（例如，敏捷开发中的“短反馈循环”就体现了KISS和快速迭代的原则）。

    + 团队协作和组织结构（例如，康威定律就暗示了代码结构会反映团队的沟通结构，而关注点分离在团队分工中也至关重要）。

    + 文档和流程设计（例如，避免重复信息，保持文档简洁清晰）。

3. 业界共识赋予其合法性（Industry consensus legitimizes the extension）：

  - 当一个原则（如DRY）被广泛认为是提升效率和可维护性的有效手段时，将其用于非代码领域就不会被视为强加，而是自然而然的、逻辑上的推导。它提供了一个共通的、高层次的语言来讨论高质量工作和设计。
    + 以 DRY 原则为例，DRY 原则的诞生，就是为了解决代码重复的问题。 字面意思和最初的实践，都集中在避免复制粘贴代码块上。
    + 那么对思想扩展，就是确保任何一段修改，都只需要在一个地方进行，然后所有引用它的地方都能自动更新。

---

## 探索的其他原则

进一步探索，不止步于此。

### 简洁性原则

1. KISS(Keep It Simple, Stupid): 不要过度设计。任何问题都应该用最简单、最直接的方法来解决。避免使用不必要的复杂性，因为复杂的代码更难理解、更难维护、也更容易出错。
2. YAGNI (You Aren't Gonna Need It):不要编写**觉得**未来可能会用到的功能。只实现当前业务需求所必需的功能。
3. DRY 在前文介绍了

### 面向对象设计原则 SOLID

- SRP(Single Responsibility Principle) 单一职责原则
  + 一个类只应该有一个引起它变化的原因，即一个类只负责一件事。如果一个类承担过多职责，修改一个职责时可能会影响其他职责，导致代码难以维护。职责单一有助于测试、复用和并行开发。把不同功能拆到不同类中。高内聚，类中的方法是一组相关的行为。
- OCP(Open-Closed Principle) 开闭原则
  + 软件实体应对扩展开放，对修改关闭。当需求变更时，尽量通过扩展系统（插入新件）来实现，而不是改动已存在的、已经可靠的代码。
- LSP(Liskov Substitution Principle) 里氏替换原则
  + 子类必须能够替换父类，并保持系统行为一致。里氏替换不只是语法正确，还要语义正确。低耦合，一个类不要有太多其他类的实例引用。
- ISP(Interface Segregation Principle) 接口隔离原则
  + 不要强迫客户依赖它们不需要的方法。接口应小而专一。拆分接口，使用多接口组合而非单个大接口。简记为：多用组合，少用继承。
- DIP(Dependency Inversion Principle) 依赖倒置原则
  + 高层模块不应依赖低层模块，两者都应依赖抽象。高层模块负责业务规则，底层模块关注技术细节，二者不应耦合。面向抽象编程，当设计一个类时，不让该类面向具体的类，二者都应面向抽象类或接口。

### 系统与过程原则

- 关注点分离：是许多其他原则（如单一职责）的基础。它要求将一个复杂的系统划分为不同的部分，每个部分只处理一个特定的关注点。
  + 例如现在软件开发的前后端分离
- 奥卡姆剃刀定律：如无必要，勿增实体。
  + 面对一个问题，两种解法：一个是引入一个复杂的第三方库，另一个是自己写10行代码就能搞定。奥卡姆剃刀定律要求选择后者，除非那个库能带来显著的、必要的额外好处。

---

## 掌握什么

- 首先，了解上面的原则肯定没有坏处，能帮助我们听懂别人在说什么行话，不至于抓瞎。重点是**看的懂**。
- 但机械记忆肯定不受推崇。熟悉上面的原则，万变不离其宗，最少要内化于心的凝练成下面几点：

  + **局部化变化**
  
  让一个需求或缺陷只需要改动极少数地方，减少牵一发而动全身的风险。

  + **降低耦合、提高内聚**
  
  让相关的东西待在一起，不相关的彼此独立，避免改 A 必改 B 的连带效应。

  + **以简单为先**
  
  优先选择直观、易读、易维护的解法，避免聪明但难懂的设计。

  + **延迟泛化**
  
  先把当下问题解决好，等真正出现多次重复或新需求时再抽象，避免过早设计。

  + **及时反馈**
  
  通过小步迭代与自动化校验尽快发现问题，用快速回路降低错误成本。

  + **边界清晰**
  
  把职责、数据与错误处理的边界明确化，使协作更顺滑、变更更可控。
