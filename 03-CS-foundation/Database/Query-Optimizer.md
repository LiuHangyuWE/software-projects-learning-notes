# 从嵌套查询到数据库的查询优化器

> 从数据库的一个题目开始，探索查询优化器。

---

### 题目

根据 `Student`、`Course` 和 `SC` 三张表，查询所有**选修了第二学期开设课程**的学生的学号、姓名、性别和系别。

下面是表的结构：
```txt
Student(Sno, Sname, Ssex, Sage, Sdept)
Course(Cno, Cname, Cpno, Ccredit, Semester)
SC(Sno, Cno, Grade)
```

### 解题思路

> **注：本题解答的 SQL 方言选择为 MySQL。**

在没有整体思路时，先局部处理，采用“由外到内，再由内到外”的构建思路。

1.  **最外层查询**
    首先分析题目的最终要求：查询学生的学号、姓名、性别和系别。这些字段均来自 `Student` 表。据此，可以先写下查询的整体框架，将 `WHERE` 条件暂时留空。

    ```sql
    SELECT Sno, Sname, Ssex, Sdept
    FROM Student
    WHERE Sno IN (...); -- 条件是学号必须在某个待确定的列表中
    ```

2.  **从核心条件入手，构建最内层查询**
    接下来需要确定 `WHERE IN` 子句中的学号列表如何生成。查询的核心条件是“第二学期开设的课程”。通过分析表结构，可以定位到 `Course` 表的 `Semester` 字段。因此，最内层查询就是从 `Course` 表中筛选出所有学期为 2 的课程号 `Cno`。

    ```sql
    SELECT Cno FROM Course WHERE Semester = 2
    ```

3.  **由内向外扩展**
    在获取了第二学期的课程号列表后，下一步就是找出选修了这些课程的学生。`SC` 表是连接学生与课程的桥梁。注意到`Course`表中有`Cno`属性，`Student`表中有`Sno`属性，它们的属性不相同，而`SC`表正好同时有这两个属性，于是。利用上一步的结果作为 `IN` 条件，可以在 `SC` 表中筛选出所有对应的学生学号 `Sno`，从而构建出查询的中间层。特别要理解下面代码的`Sno`和`Cno`的使用。这是嵌套查询的难点，理解后，所有类似的查询找好表与表之间的关系一通百通，一马平川。

    ```sql
    SELECT Sno
    FROM SC
    WHERE Cno IN (
        SELECT Cno FROM Course WHERE Semester = 2
    )
    ```

4.  **不急，还能优化一波**
    最后，将中间层的查询嵌入到第一步搭建的框架中，形成完整的 SQL 语句。在审视整个查询时，我发现一个可以优化的地方：如果一个学生选修了多门第二学期的课程，中间层会返回重复的学号。为了逻辑上的严谨并提升潜在效率，在中间层加上 `DISTINCT` 关键字进行去重。

### 完整代码

```sql
-- 步骤1：最外层框架
SELECT
    Sno,
    Sname,
    Ssex,
    Sdept
FROM
    Student
WHERE
    Sno IN (
        -- 步骤4：加入 DISTINCT 进行优化
        SELECT DISTINCT Sno
        -- 步骤3：中间层查询
        FROM SC
        WHERE Cno IN (
            -- 步骤2：最内层查询
            SELECT Cno
            FROM Course
            WHERE Semester = 2
        )
    );
```

---

## 额外思考，实际上精彩刚刚开始

> 等等，<u>distinct</u> 的书写当然是一个好习惯，并且实际开发中能意识到这一步是很好的，但是操作者若想不起来，写了一个（看上去）性能更低的 SQL 语句就真的会让性能大幅下降吗（当人不是这样小的表，实际开发的数据量一般是比较大的）？

其实不然。市面上主流的成熟的数据库设计考虑到了这点。在执行一条SQL语句时，它并不是被原封不动地拿去执行的。会首先经过**查询优化器**的处理。优化器经常会重写我们的SQL，把它变成逻辑上等价、但执行效率更高的形式。

像 `WHERE Sno IN (SELECT Sno FROM ...)` 这样的写法非常普遍。优化器知道这种模式的本质是“检查是否存在匹配项”。因此，优化器通常不会真的先去执行子查询，生成一个巨大的 Sno 列表，然后再去 Student 表里逐个匹配。它会把整个查询重写为一个更高效的操作，最常见的就是 SEMI-JOIN (半连接)。


先介绍 **SEMI-JOIN**。
- SEMI-JOIN 是一种特殊的连接操作。它会返回第一张表 (Student) 中，在第二张表（子查询的结果集）里能找到至少一个匹配项的那些行。对此题 Student 表中的某一行，只要在子查询结果里找到一个匹配，它就会被立即返回，并且不会再继续寻找更多的匹配。因此，Student 表的每一行最多只会被返回一次。

优化器看到 IN 子句，会识别出“寻找至少一个匹配”的意图，然后将其转化为 SEMI-JOIN。在 SEMI-JOIN 的逻辑下，子查询结果中 Sno 是否有重复值是完全不重要的。因此，**优化器会认为子查询中的 DISTINCT 是多余的，并常常在生成执行计划时直接将其忽略。** 

所以，写`distinct`是一种素养，像是一份严谨的标准答案该有的样子（也确实是我的题解中的样子，想到要用`distinct`优化还让我高兴了一会儿自己的机灵）。不写也没啥，但要有一些额外的偏向底层的知识支撑自己，能在别人提出质疑的时候从容地解释自己的每一步。同样都是不写`distinct`，一个清楚地知道自己在干什么，一个则是更偏向于凭运气。

这种素养也是初级工程师向架构师转变要具备的：知其所以然。

---

## 窥视了查询优化器的一角，下面更全面地认识它
在前面的基础上，可以顺延出查询优化器的进一步探索。查询优化器负责为用户提交的 SQL 查询找到成本最低的执行计划。其工作流程可以清晰地划分为三个核心阶段：解析与标准化、逻辑优化和物理优化。

### 阶段一：解析、标准化

此阶段的目标是“理解”SQL语句，并将其转换为数据库内部系统可以处理的标准化、结构化格式。

1.  **语法解析**

      * **任务**: 检查SQL语句的语法是否正确（例如，关键字拼写、标点符号等）。
      * **实现**: 类似于编程语言的编译器，使用词法分析器和语法分析器将 SQL 文本字符串转换为一个树形结构。
      * **产物**: **解析树 (Parse Tree)** 或 **抽象语法树 (AST)**。这个树状结构清晰地表达了 SQL 的各个组成部分及其逻辑关系。

2.  **语义分析**

      * **任务**: 验证解析树的语义合法性。包括
          * 检查查询中引用的表、视图、列是否存在于数据库中。
          * 验证用户是否拥有对这些对象的访问权限。
          * 进行类型检查，确保操作的合法性（例如，不能对日期字段进行数学乘法）。
      * **产物**: 一个经过验证和注解的内部数据结构，为后续优化做好了准备。

### 阶段二：逻辑优化

这是优化器进行**基于规则 (Rule-Based)** 的等价变换阶段。它在不改变查询最终结果的前提下，通过一系列规则重写查询，以寻找一个逻辑上更优的执行路径。此阶段不关心具体的执行成本。包括：

  * **子查询展开 (Subquery Unnesting)**: 将 `IN`, `EXISTS` 等子查询尽可能地转换为等价的 `JOIN` 操作（如 `INNER JOIN` 或 `SEMI-JOIN`）。
      * **示例**: `WHERE Sno IN (SELECT Sno ...)` 常常被重写为 `... SEMI-JOIN ...`。这个重写过程可以让优化器识别出子查询中的 `DISTINCT` 是否是冗余的。

  * **谓词下推 (Predicate Pushdown)**: 将 `WHERE` 子句中的过滤条件尽可能地移动到执行计划的前端，以便尽早地过滤掉无效数据，大幅减少后续操作（如连接）需要处理的数据量。
      * **示例**:
        ```sql
        -- 原始查询
        SELECT 
            * 
        FROM 
            Student S 
        JOIN 
            SC ON S.Sno = SC.Sno 
        WHERE 
            S.Sdept = 'CS';

        -- 优化后逻辑：先过滤Student表，再进行JOIN
        SELECT 
            * 
        FROM (
                SELECT * FROM Student 
                WHERE Sdept = 'CS'
            ) 
            S JOIN SC ON S.Sno = SC.Sno;
        ```

  * **常量折叠 (Constant Folding)**: 在编译阶段直接计算出常量表达式的结果。
      * **示例**: `WHERE Sage > 2025 - 2005` 会被直接转换为 `WHERE Sage > 20`。

  * **视图合并 (View Merging)**: 将查询中引用的视图展开，把视图的定义直接合并到主查询中，从而使整个查询能够进行统一的、全局的优化。

### 阶段三：物理优化

为逻辑计划选择具体的物理实现算法，并**基于成本估算 (Cost-Based)** 来选择一个最终的、成本最低的执行计划。

1.  **物理操作选择**: 为逻辑操作选择具体的物理执行算法。每种算法都有其适用的场景。
      * **示例**:
          * **逻辑 `JOIN`**: 可选择 `Nested Loop Join` (嵌套循环)、`Hash Join` (哈希连接) 或 `Merge Join` (归并连接)。
          * **逻辑 `Scan` (表访问)**: 可选择 `Full Table Scan` (全表扫描) 或 `Index Scan` (索引扫描)。

1.  **成本估算 (Cost Estimation)**：优化器利用数据库内部维护的**统计信息 (Statistics)** 来估算每个备选执行计划的成本（主要是I/O和CPU消耗）。
      * **依赖的统计信息**:
          * 表中的总行数。
          * 列的基数 (Cardinality)，即列中不重复值的数量。
          * 数据分布直方图 (Histograms)，描述列中值的分布情况。
      * **应用**: 根据 `WHERE Sdept = 'CS'` 条件，优化器通过统计信息估算出将要返回的数据行数，从而决定是使用索引扫描（结果集很小）还是全表扫描（结果集很大）更划算。

1.  **搜索最优计划**：由于复杂查询的可能执行计划组合数量巨大，优化器会使用高效的搜索算法（如**动态规划**）来避免遍历所有可能性，从而在巨大的搜索空间中找到一个成本最低的“最优”执行计划。

最终，物理优化阶段产生的成本最低的**执行计划 (Execution Plan)** 会被交给数据库的执行引擎去真正地执行，完成数据查询。